<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: clojure | adereth]]></title>
  <link href="http://adereth.github.io/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://adereth.github.io/"/>
  <updated>2013-11-23T19:37:38-05:00</updated>
  <id>http://adereth.github.io/</id>
  <author>
    <name><![CDATA[Matt Adereth]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A few interesting Clojure microbenchmarks]]></title>
    <link href="http://adereth.github.io/blog/2013/11/22/a-few-interesting-clojure-microbenchmarks/"/>
    <updated>2013-11-22T07:50:00-05:00</updated>
    <id>http://adereth.github.io/blog/2013/11/22/a-few-interesting-clojure-microbenchmarks</id>
    <content type="html"><![CDATA[<script src="http://d3js.org/d3.v2.js"></script>


<p></p>

<!--       font-family: Arial, sans-serif; "Menlo","Monaco","Andale Mono","lucida console","Courier New",monospace;-->


<!-- CSS Styles: -->


<div>
  <style type="text/css">

    .chart {
      font-family: monospace;
      font-size: 10px;
      margin-top: -40px;
    }

    .bar {
      fill: grey;
    }

    .axis path, .axis line {
      fill: none;
      stroke: #000;
      shape-rendering: crispEdges;
    }

  </style>
</div>




<!-- Global Variables and Handlers: -->


<script type="text/javascript">

  var margin = {top: 40, right: 40, bottom: 60, left: 110},
      width = $('.entry-content').width();

  $(window).resize(function() {
    width = $('.entry-content').width();
  });

  function draw(data, chart, height) {
    
    $(chart).empty();

    var x = d3.scale.linear()
        .domain([0, d3.max(data, function(d) { return d.mean})])
        .range([0, width - margin.left - margin.right]);

    var y = d3.scale.ordinal()
        .domain(d3.range(data.length))
        .rangeRoundBands([height - margin.top - margin.bottom, 0], 0.2);

    var xAxis = d3.svg.axis()
        .scale(x)
        .orient('bottom')
        .tickPadding(8)
    .ticks(8);

    var yAxis = d3.svg.axis()
        .scale(y)
        .orient('left')
        .tickPadding(8)
        .tickSize(0);

    var svg = d3.select(chart).append('svg')
        .attr('width', width)
        .attr('height', height)
        .attr('class', 'chart')
          .append('g')
        .attr('transform', 'translate(' + margin.left + ', ' + margin.top + ')');

    svg.selectAll('.chart')
        .data(data)
    .enter().append('rect')
        .attr('class', 'bar')
        .attr('y', function(d, i) { return y(i) })
        .attr('width', function(d) { return x(d.mean) })
        .attr('height', y.rangeBand());

    svg.append('g')
        .attr('class', 'x axis')
        .attr('transform', 'translate(0, ' + y.rangeExtent()[1] + ')')
        .call(xAxis);

    svg.append("text")
    .attr("class", "x label")
    .attr("text-anchor", "end")
        .attr("x", width / 2 - 45)
        .attr("y", height - 60)
        .text("nanoseconds");

    svg.append('g')
        .attr('class', 'y axis')
        .call(yAxis)
      .selectAll('text')
        .text(function(d) { return data[d].code; });
    
  }
  
  function drawWithResize(data, chart, height) {
    draw(data, chart, height);
    $(window).resize(function() {draw(data, chart, height); })
  }
;


</script>


<p><a href="http://ideolalia.com/">Zach Tellman</a> delivered a really informative and practical unsession at <a href="http://clojure-conj.org/">Clojure Conj 2013</a> entitled &ldquo;Predictably Fast Clojure.&rdquo;  It was described as:</p>

<blockquote><p>An exploration of some of the underlying mechanisms in Clojure, and how to build an intuition for how fast your code should run. Time permitting, we&rsquo;ll also explore how to work around these mechanisms, and exploit the full power of the JVM.</p></blockquote>

<p>I&rsquo;d like to share a few interesting things that I learned from this talk and that I subsequently verified and explored.</p>

<h2>How to benchmark</h2>

<p>It turns out that benchmarking is hard and benchmarking on the JVM is even harder.  Fortunately, the folks at the Elliptic Group have thought long and hard about how to do it right and have written <a href="http://www.ibm.com/developerworks/views/java/libraryview.jsp?search_by=robust+java+benchmarking">a couple of great articles</a> on the matter.  Hugo Duncan&rsquo;s <a href="https://github.com/hugoduncan/criterium">Criterium library</a> makes it super easy to use these robust techniques.</p>

<p>All the benchmarks in this post were run on my dual-core 2.6 GHz Intel Core i5 laptop.  The JVM was started with <code>lein with-profile production repl</code>, which enables more aggressive JIT action at the cost of slower start times.  If you try to use Criterium without this, you&rsquo;ll get warnings spewed for every benchmark you run.</p>

<h2>Surprising operations on lists, vectors, and tuples</h2>

<p>The first thing that he discussed was the relatively poor performance of <code>first</code> on vectors.</p>

<p>For the tests, I made the some simple collections:
<code>clojure
(def ve [0 1 2])
(def li '(0 1 2))
(def tu (clj-tuple/tuple 0 1 2))
</code></p>

<p>And then I timed them each with <code>first</code> and <code>(nth coll 0)</code>:</p>

<div id='chart-1'></div>


<script type='text/javascript'>
  var data = [
      {code: "(first ve)", mean: 59.387551, lower: 56.557346, upper: 75.434730},
      {code: "(first li)", mean: 11.814687, lower: 9.933760, upper: 17.651180},
      {code: "(first tu)", mean: 12.026005, lower: 11.096498, upper: 17.716830},
      {code: "(nth ve 0)", mean: 14.507457, lower: 13.379794, upper: 19.732508},
      {code: "(nth li 0)", mean: 132.042247, lower: 123.849601, upper: 173.395438},
      {code: "(nth tu 0)", mean: 11.240653, lower: 10.739338, upper: 12.333350},
      ];
  data.reverse();
  drawWithResize(data, '#chart-1', 275);
</script>


<p>The <a href="http://clojuredocs.org/clojure_core/clojure.core/first">documentation</a> says that <code>first</code> &ldquo;calls seq on its argument.&rdquo;  This is effectively true, but if you look at the <a href="https://github.com/clojure/clojure/blob/1.5.x/src/jvm/clojure/lang/RT.java#L575">source</a> you&rsquo;ll see that if the collection implements <code>ISeq</code>, <code>seq</code> doesn&rsquo;t need to be called.  As a result, the performance of <code>first</code> on lists, which do implement <code>ISeq</code>, is much better than on vectors, which don&rsquo;t.  Zach took advantage of this observation in his <a href="https://github.com/ztellman/clj-tuple">clj-tuple</a> library and made sure that tuples implement <code>ISeq</code>.</p>

<p>What&rsquo;s really interesting is that you can use <code>(nth coll 0)</code> to get the first element of a vector faster that you can with <code>first</code>.  Unfortunately, this only does well with vectors.  The performance is abysmal when applied to lists, so you should stick to <code>first</code> if you don&rsquo;t know the data structure you are operating on.</p>

<p>The apparent slowness of <code>seq</code> on a vector made me wonder about the <code>empty?</code> function, which uses <code>seq</code> under the hood:</p>

<p><code>clojure
user=&gt; (source empty?)
(defn empty?
  "Returns true if coll has no items - same as (not (seq coll)).
  Please use the idiom (seq x) rather than (not (empty? x))"
  {:added "1.0"
   :static true}
  [coll] (not (seq coll)))
</code></p>

<p>If using <code>seq</code> is so slow, perhaps we can get better performance by just getting the count of elements and testing if it&rsquo;s zero:</p>

<div id='chart-empty'></div>


<script type='text/javascript'>
  var dataE = [
{code: "(empty? ve)", mean: 22.436542, lower: 22.052842, upper: 23.003189},
{code: "(empty? li)", mean: 12.293540, lower: 11.680523, upper: 15.369996},
{code: "(empty? tu)", mean: 18.512765, lower: 17.351246, upper: 22.757244},
{code: "(= 0 (count ve))", mean: 11.209652, lower: 10.451370, upper: 15.123089},
{code: "(= 0 (count li))", mean: 10.710336, lower: 10.417919, upper: 11.667121},
{code: "(= 0 (count tu))", mean: 10.741061, lower: 10.396224, upper: 13.246183},
      ];
  dataE.reverse();
  drawWithResize(dataE, '#chart-empty', 275);
</script>


<p>Of course, this is a bad idea for lazy sequences and should probably be avoided, as we&rsquo;ll incur a cost that is linear in the size of the sequence just to get the count.</p>

<p>I don&rsquo;t think this will affect my day to day code, but it certainly is interesting and surfaced a bit more about how things actually work in Clojure.</p>

<h2>Inconsistent protocol timings</h2>

<p>This was a surprising one that also peeled back a layer on Clojure&rsquo;s implementation.  In Fogus&rsquo;s <a href="http://blog.fogus.me/2011/10/14/why-clojure-doesnt-need-invokedynamic-but-it-might-be-nice/">Why Clojure might not need invokedynamic, but it might be nice</a>, he explained:</p>

<blockquote><p>Clojure&rsquo;s protocols are polymorphic on the type of the first argument. The protocol functions are call-site cached (with no per-call lookup cost if the target class remains stable). In other words, the implementation of Clojure&rsquo;s protocols are built on polymorphic inline caches.</p></blockquote>

<p>The consequence of this is that we will see worse performance if the type of the first argument to a protocol&rsquo;s method keeps changing.  I made a simple test to see how significant this is:</p>

<p>```clojure
(defprotocol P
  (f [x]))</p>

<p>(extend-protocol P
  String (f [<em>] 1)
  Long (f [</em>] 2))</p>

<p>(defn g [x y]
  (+ (f x) (f y)))</p>

<p>(def s0 &ldquo;foo&rdquo;)
(def s1 &ldquo;bar&rdquo;)
(def n0 0)
(def n1 1)
```</p>

<p><code>g</code> calls <code>f</code> on both its arguments and we expect <code>f</code> to perform best when it&rsquo;s consistently called on a single type:</p>

<div id='chart-2'></div>


<script type='text/javascript'>
  var data2 = [
{code: "(g n0 n1)", mean: 21.597699},
{code: "(g s0 s1)", mean: 22.550262},
{code: "(g n0 s0)", mean: 37.527409}
      ];
  data2.reverse();
  drawWithResize(data2, '#chart-2', 190);
</script>


<p>The expectation was correct.  There was some subsequent talk about whether the penalty of this cache miss was predictable.  Theoretically, the cost could be unbounded if you extend the protocol with enough types and have horrible luck with the hash codes of those types colliding, but my understanding of the caching logic is that it will usually be the small constant that we observed here.</p>

<p>You can see why by taking a look at how the cache works in <a href="https://github.com/clojure/clojure/blob/1.5.x/src/jvm/clojure/lang/MethodImplCache.java#L76">MethodImplCache.java</a>.  The hash code of the class is shifted and masked by values that form a simple perfect hash, which is determined by the <a href="https://github.com/clojure/clojure/blob/1.5.x/src/clj/clojure/core.clj#L5971"><code>maybe-min-hash</code> function</a>.  The use of a perfect hash means that we should see consistent lookup times for even moderately large caches.</p>

<p>In the rare case that a perfect hash can&rsquo;t be found by <code>maybe-min-hash</code>, the cache falls back to using a <code>PersistentArrayMap</code>, which can have slightly worse performance.  In any case, I don&rsquo;t think there&rsquo;s much to worry about here.</p>

<p>One neat thing I discovered while testing all of this is that you don&rsquo;t suffer this cache-miss penalty if you declare that you support a protocol in your <code>deftype</code> or if you <code>reify</code>, but you do if you use <code>extend-protocol</code>:</p>

<p>```clojure
(deftype X []
  P
  (f [_] 3))
(def dt (X.))</p>

<p>(def re (reify P (f [_] 4)))</p>

<p>(deftype Y [])
(extend-protocol P
  Y
  (f [_] 5))
(def ep (Y.))
```</p>

<div id='chart-3'></div>


<script type='text/javascript'>
  var data3 = [
      {code: "(g s0 dt)", mean: 19.389459},
      {code: "(g s0 re)", mean: 19.747690},
      {code: "(g s0 ep)", mean: 76.890915},
      ];
  data3.reverse();
  drawWithResize(data3, '#chart-3', 190);
</script>


<p>My understanding is that the declaration of a protocol results in the creation of function objects and in a corresponding interface.  When the function is called, the first thing it does when trying to dispatch is see if the first argument implements the interface for the protocol that declared the function in the first place.  If it did, the corresponding method on the object is called.  If it doesn&rsquo;t implement the interface, it next uses the MethodImplCache and has the potential to suffer from the cache miss.  What&rsquo;s great is that if the object does implement the interface, the most recent entry in the cache is unaffected.</p>

<p>We can verify that the reified object and the instance of the type that was deftyped with the protocol both implement the interface and the other one doesn&rsquo;t:</p>

<p>```clojure
user=> (supers (type dt))</p>

<h1>{user.P clojure.lang.IType java.lang.Object}</h1>

<p>user=> (supers (type re))</p>

<h1>{clojure.lang.IObj user.P java.lang.Object clojure.lang.IMeta}</h1>

<p>user=> (supers (type ep))</p>

<h1>{clojure.lang.IType java.lang.Object}</h1>

<p>```</p>

<h2>Determining if your type hints worked</h2>

<p>Often when we want to squeeze every last bit of performance, we use type hints to avoid reflection and to force the use of primitives.  Zach demonstrated how to use Gary Trakhman&rsquo;s <a href="https://github.com/gtrak/no.disassemble">no.disassemble</a> to inspect the byte code of a function directly from the REPL.</p>

<p>I haven&rsquo;t gotten to play with it yet, but the ability to quickly compare the byte code between two implementations in the REPL looked amazing.</p>

<h2>Thanks</h2>

<p>Thanks to Zach Tellman for the informative presentation that motivated this and to David Greenberg for help investigating the protocol performance issues.</p>

<p>If there&rsquo;s anything I got wrong, please let me know in the comments&hellip; thanks!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[core.matrix + Apache Commons Math]]></title>
    <link href="http://adereth.github.io/blog/2013/11/08/core-dot-matrix-plus-apache-commons-math/"/>
    <updated>2013-11-08T08:08:00-05:00</updated>
    <id>http://adereth.github.io/blog/2013/11/08/core-dot-matrix-plus-apache-commons-math</id>
    <content type="html"><![CDATA[<p>I&rsquo;d like to share a little project I did to make it more convenient to use Apache Commons Math&rsquo;s linear algebra classes with Clojure.</p>

<h2>Apache Commons Math</h2>

<p><a href="http://commons.apache.org/proper/commons-math/index.html">Apache Commons Math</a> is a Java library of mathematics and statistics components.  It&rsquo;s loaded with useful things including:</p>

<ul>
<li>Statistics</li>
<li>Data Generation</li>
<li>Probability Distributions</li>
<li>Machine Learning</li>
<li>Optimization</li>
<li>Numerical Analysis</li>
<li>Curve Fitting</li>
<li>Linear Algebra</li>
<li>Complex Numbers</li>
<li>Ordinary Differential Equations</li>
</ul>


<p>I highly recommend at least skimming the <a href="http://commons.apache.org/proper/commons-math/userguide/index.html">User Guide</a>.  It&rsquo;s useful to know what&rsquo;s already available and you may even discover a branch of mathematics that you find interesting.</p>

<p>As with most Java libraries, it&rsquo;s generally pleasant to use from Clojure via interop.  Of course, there are a few places where there&rsquo;s unnecessary object constructiion just to get at methods that could easily be static and there are a few others where <em>mutation</em> rears its ugly head.  For the non-static cases, it&rsquo;s trivial enough to create a <code>fn</code> that creates the object and calls the method you need.</p>

<p>Many of the methods in the library either accept or return matrices and vectors, using the <a href="http://commons.apache.org/proper/commons-math/apidocs/org/apache/commons/math3/linear/RealMatrix.html">RealMatrix</a> and <a href="http://commons.apache.org/proper/commons-math/apidocs/org/apache/commons/math3/linear/RealVector.html">RealVector</a> interfaces.  While we could use interop to create and use these, it&rsquo;s nice to be able to use them in idiomatic Clojure and even nicer to be able to seamlessly use them with pure Clojure data structures.</p>

<h2>core.matrix</h2>

<p><a href="https://github.com/mikera/core.matrix">core.matrix</a> is a library and API that aims to make matrix and array programming idiomatic, elegant and fast in Clojure.  It features pluggable support for different underlying matrix library implementations.</p>

<p>For all my examples, I&rsquo;ve included core.matrix as <code>m</code>:
<code>clojure
(require '[clojure.core.matrix :as m])
</code></p>

<h2>apache-commons-matrix</h2>

<p>After implementing a few protocols, I was able to get full support for Apache Commons Math&rsquo;s matrices and vectors into the core.matrix API, which I&rsquo;ve released as <a href="https://github.com/adereth/apache-commons-matrix">adereth/apache-commons-matrix</a>.</p>

<p>Once you&rsquo;ve loaded <code>apache-commons-matrix.core</code>, you can begin using the <code>core.matrix</code> functions on any combination of Apache Commons Math matrices and vectors and any other implementation of matrix and vectors, including Clojure&rsquo;s built-in persistent vectors.</p>

<p>Without this, you have to write some pretty cumbersome array manipulation code to get the interop to work.  For instance:
```clojure
(org.apache.commons.math3.linear.Array2DRowRealMatrix.
 (into-array [(double-array [1 1])</p>

<pre><code>          (double-array [1 0])]))
</code></pre>

<p>;; #<Array2DRowRealMatrix Array2DRowRealMatrix{ {1.0,1.0}, {1.0,0.0} }>
```</p>

<p>&hellip;versus:</p>

<p><code>clojure
(m/with-implementation :apache-commons
  (m/matrix [[1 1] [1 0]]))
;; #&lt;Array2DRowRealMatrix Array2DRowRealMatrix{ {1.0,1.0}, {1.0,0.0} }&gt;
</code></p>

<p>If you&rsquo;re working from the REPL or otherwise don&rsquo;t care about indirectly changing the behavior of your code, you could even avoid <code>with-implementation</code> and just make <code>:apache-commons</code> the default by evaluating:
<code>clojure
(m/set-current-implementation :apache-commons)
</code></p>

<p>Things become really convenient when you start combining Apache Commons Math data structures with Clojure&rsquo;s.  For example, we can multiply a <code>RealMatrix</code> and a vector:</p>

<p>```clojure
(def fib-matrix
  (m/with-implementation :apache-commons</p>

<pre><code>(m/matrix [[1 1] [1 0]])))
</code></pre>

<p>(m/transform fib-matrix [5 3])
;; #<ArrayRealVector {8; 5}>
```</p>

<p>Note that the type of the result depends on the implementation of the first parameter:</p>

<p>```clojure
(def fib-vector</p>

<pre><code>(m/with-implementation :apache-commons
  (m/array [5 3])))
</code></pre>

<p>;; #<ArrayRealVector {5; 3}></p>

<p>(m/transform [[1 1] [1 0]] fib-vector)
;; [8.0 5.0]
```</p>

<h2>Implementation Experience</h2>

<p>It was really easy to follow the <a href="https://github.com/mikera/core.matrix/wiki/Implementation-Guide">Implementation Guide for core.matrix</a> that Mike Anderson wrote.  There were just a handful of protocols that I needed to implement and I magically got all the functionality of core.matrix.  The test framework is incredibly thorough and it immediately revealed a number of subtle bugs in my initial implementation.  Overall, it was a great experience and I wish that all interfaces provided such nice documentation and testing.</p>

<h2>Conclusion</h2>

<p>If you&rsquo;re doing any math on the JVM, you should at least check out what Apache Commons Math has to offer.  If you&rsquo;re using it in Clojure, I recommend using core.matrix instead of interop whenever possible.  If you do try this out, please let me know if there&rsquo;s anything missing or just send me a pull request!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Efficiently Computing Kendall's Tau]]></title>
    <link href="http://adereth.github.io/blog/2013/10/30/efficiently-computing-kendalls-tau/"/>
    <updated>2013-10-30T21:45:00-04:00</updated>
    <id>http://adereth.github.io/blog/2013/10/30/efficiently-computing-kendalls-tau</id>
    <content type="html"><![CDATA[<p>Typically when people talk about correlation they are referring to the <a href="http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient">Pearson&rsquo;s product-moment coefficient</a>:</p>

<p>$$\rho_{X,Y}={E[(X-\mu_X)(Y-\mu_Y)] \over \sigma_X\sigma_Y}$$</p>

<p>The Pearson coefficient is 1 if the datasets have a perfectly positive linear relationship and -1 if they have a perfectly negative linear relationship.  But what if our data has a clear positive relationship, but it&rsquo;s not linear?  Or what if our data isn&rsquo;t even numeric and doesn&rsquo;t have a meaningful way of computing the average, $\mu$, or standard deviation, $\sigma$?</p>

<p>In these cases, Kendall&rsquo;s Tau is a useful way of measuring the correlation since it only requires that we have a <a href="http://en.wikipedia.org/wiki/Total_order">total ordering</a> for each of our datasets.  For each pair of observations, $(x_1, y_1)$ and $(x_2, y_2)$, we call the pair <em>concordant</em> if:
$$x_1 &lt; x_2 \text{ and } y_1 &lt; y_2$$
$$\text{or}$$
$$x_1 > x_2 \text{ and } y_1 > y_2$$
&hellip;and we call the pair <em>discordant</em> if:
$$x_1 &lt; x_2 \text{ and } y_1 > y_2$$
$$\text{or}$$
$$x_1 > x_2 \text{ and } y_1 &lt; y_2$$
If $x_1 = x_2 \text{ or } y_1 = y_2$, the pair is neither concordant nor discordant.</p>

<p>Kendall&rsquo;s Tau is then defined as:
$$\tau = \frac{n_c-n_d}{\frac{1}{2} n (n-1) }$$
Where $n_c$ is the number of concordant pairs and $n_d$ is the number of discordant pairs.
Since $n (n-1) / 2$ is the total number of pairs, this value ranges from -1 to 1.</p>

<p>Unfortunately, this approach doesn&rsquo;t deal well with tied values.  Consider the following set of $(x,y)$ observations:
$$(1,1), (1,1), (2,2), (3,3)$$
There&rsquo;s a perfectly positive linear relationship between X and Y, but only 5 of the 6 pairs are concordant.  For this case we want to use the $\tau_B$ modified version:</p>

<p>$$\tau_B = \frac{n_c-n_d}{\sqrt{(n_0-n_1)(n_0-n_2)}}$$</p>

<p>&hellip;where:</p>

<p>$$n_0 = n(n-1)/2$$
$$n_1 = \text{Number of pairs with tied values in } X$$
$$n_2 = \text{Number of pairs with tied values in } Y$$</p>

<h2>Computing Naively</h2>

<p>We can compute $\tau_B$ in $O(n^{2})$ by looking at every pair of observations and tallying the number of concordant, discordant, and tied pairs.  Once we have the tallies, we&rsquo;ll apply the formula:
```clojure
(defn kendalls-tau-from-tallies
  [{:keys [concordant discordant pairs x-ties y-ties]}]
  (/ (&ndash; concordant discordant)</p>

<pre><code> (Math/sqrt (* (- pairs x-ties)
               (- pairs y-ties)))))
</code></pre>

<p>```</p>

<p>For a given pair of observations, we&rsquo;ll construct a map describing which tallies it will contribute to:
```clojure
(defn kendall-relations [[[x1 y1] [x2 y2]]]
  (cond
   (and (= x1 x2) (= y1 y2)) {:x-ties 1 :y-ties 1}
   (= x1 x2) {:x-ties 1}
   (= y1 y2) {:y-ties 1}
   (or (and (&lt; x1 x2) (&lt; y1 y2))</p>

<pre><code>   (and (&gt; x1 x2) (&gt; y1 y2))) {:concordant 1}
</code></pre>

<p>   :else {:discordant 1}))
```</p>

<p>Now we need a way of generating every pair:
```clojure
(defn pairs [[o &amp; more]]
  (if (nil? o) nil</p>

<pre><code>  (concat (map #(vector o %) more)
          (lazy-seq (pairs more)))))
</code></pre>

<p>;; (pairs [1 2 3 4])
;; => ([1 2] [1 3] [1 4] [2 3] [2 4] [3 4])
<code>
Finally, we put it all together by computing the relations tally for each pair and combining them using `merge-with`:
</code>clojure
(defn naive-kendalls-tau [xs ys]
  (let [observations (map vector xs ys)</p>

<pre><code>    relations (map kendall-relations (pairs observations))
    tallies (reduce (partial merge-with +
                             {:pairs 1})
                    {:concordant 0 :discordant 0
                     :x-ties 0 :y-ties 0 :pairs 0}
                    relations)]
(kendalls-tau-from-tallies tallies)))
</code></pre>

<p>```</p>

<h2>Knight&rsquo;s Algorithm</h2>

<p>In 1966, William R. Knight was a visiting statistician at the Fisheries Research Board of Canada.  He wrote:</p>

<blockquote><p>The problem of calculating Kendall&rsquo;s tau arose while attempting to evaluate species associations in catches by the Canadian east coast offshore fishery.  Sample sizes ranging up to 400 were common, making manual calculations out of the question; indeed, an initial program using an asymptotically inefficient method proved expensively slow.</p></blockquote>

<p>Necessity is the mother of invention, so he came up with a clever algorithm for computing Kendall&rsquo;s Tau in $O(n \log{n})$ which he published in his paper entitled &ldquo;<a href="http://www.jstor.org/stable/2282833">A Computer Method for Calculating Kendall&rsquo;s Tau with Ungrouped Data</a>&rdquo;.</p>

<p>First, sort the observations by their $x$ values using your favorite $O(n \log{n})$ algorithm.  Next, sort <em>that</em> sorted list by the $y$ values using a slightly modified <a href="http://en.wikipedia.org/wiki/Merge_sort">merge sort</a> that keeps track of the size of the swaps it had to perform.</p>

<p>Recall that merge sort works as follows:</p>

<ol>
<li>Divide the unsorted list into $n$ sublists, each containing 1 element (a list of 1 element is considered sorted).</li>
<li>Repeatedly merge sublists to produce new sublists until there is only 1 sublist remaining. This will be the sorted list.</li>
</ol>


<p><img class="center  <a" src="href="http://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif">http://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif</a>" title="Merge Sort Animation" >
<em>(description and animation from <a href="http://en.wikipedia.org/wiki/Merge_sort">Wikipedia</a>)</em></p>

<p>The trick is performed when merging sublists.  The list was originally sorted by $x$ values, so whenever an element from the second sublist is smaller than the next element from the first sublist we know that the corresponding observation is discordant with however many elements remain in the first sublist.</p>

<p>We can implement this modified merge sort by first handling the case of merging two sorted sequences:</p>

<p>```clojure
(defn merge-two-sorted-seqs-and-count-discords
  &ldquo;Takes a sequence containing two sorted sequences and merges them.  If an
element from the second sequence is less than the head of the first sequence, we
know that it was discordant with all the elements remaining in the first
sequence.  This is the insight that allows us to avoid the O(n<sup>2</sup>) comparisons in
the naive algorithm.</p>

<p>A tuple containing the count of discords and the merged sequence is returned.&ldquo;
  [[coll1 coll2]]
  (loop [swaps 0</p>

<pre><code>     ;; Explicitly track the remaining counts to avoid doing a linear
     ;; scan of the sequence each time, which would get us back to O(n^2)
     remaining-i (count coll1)
     remaining-j (count coll2)

     [i &amp; rest-i :as all-i] coll1
     [j &amp; rest-j :as all-j] coll2
     result []]
(cond
 (zero? remaining-j) [swaps (concat result all-i)]
 (zero? remaining-i) [swaps (concat result all-j)]
 (&lt;= i j) (recur swaps
                 (dec remaining-i) remaining-j
                 rest-i all-j (conj result i))
 :j&gt;i (recur (+ swaps remaining-i)
              remaining-i (dec remaining-j)
              all-i rest-j (conj result j)))))
</code></pre>

<p><code>
Now, we can do the full merge sort by applying that function to piece sizes that double until the whole collection is covered by a single sorted piece:
</code>clojure
(defn merge-sort-and-count-discords
  &ldquo;Returns a vector containing the number of discordant swaps and the sorted
collection.&rdquo;
  [coll]
  (loop [swaps 0</p>

<pre><code>     coll coll
     piece-size 1]
(let [pieces (partition-all piece-size coll)
      piece-pairs (partition-all 2 pieces)]
  (if (-&gt; piece-pairs first second)
    (let [[new-swaps new-coll]
          (-&gt;&gt; piece-pairs
               (map merge-two-sorted-seqs-and-count-discords)
               (reduce (fn [[acc-s acc-c] [s c]]
                         [(+ acc-s s) (concat acc-c c)])
                       [0 []]))]
      (recur (+ swaps new-swaps) new-coll (* 2 piece-size)))
    [swaps coll]))))
</code></pre>

<p>```</p>

<p>The only thing we are missing now is the tallies of tied pairs.  We could use <a href="http://clojuredocs.org/clojure_core/clojure.core/frequencies"><code>clojure.core/frequencies</code></a>, but Knight&rsquo;s original paper alludes to a different way which takes advantage of the fact that at different stages of the algorithm we have the list sorted by $X$ and then $Y$.  Most implementations do something like:</p>

<p>```clojure
(defn tied-pair-count [sorted-coll]
  (&ndash;>> sorted-coll</p>

<pre><code>   (partition-by identity)
   (map count)
   (map #(/ (* % (dec %)) 2))
   (reduce +)))
</code></pre>

<p>```</p>

<p>Now we have all the pieces, so we just have to put them together:</p>

<p>```clojure
(defn knights-kendalls-tau [xs ys]
  (let [observations (sort (map vector xs ys))</p>

<pre><code>    n (count observations)
    pair-count (/ (* n (dec n)) 2)
    xy-pair-ties (tied-pair-count observations)
    x-pair-ties (tied-pair-count (map first observations))
    [swaps sorted-ys] (merge-sort-and-count-discords
                       (map second observations))
    y-pair-ties (tied-pair-count sorted-ys)
    concordant-minus-discordant (- pair-count
                                   x-pair-ties
                                   y-pair-ties
                                   (- xy-pair-ties)
                                   (* 2 swaps))]
(/ concordant-minus-discordant
   (Math/sqrt (* (- pair-count x-pair-ties)
                 (- pair-count y-pair-ties))))))
</code></pre>

<p>```</p>

<h2>Conclusion</h2>

<p>There are certainly many things I would write differently above if I was really trying for performance.  The goal here was to clearly illustrate the algorithm and maintain the asymptotic run-time characteristics.</p>

<p>Also, I recently submitted <a href="https://issues.apache.org/jira/browse/MATH-814">a patch</a> to the Apache Commons Math library that contains an implementation of this in pure Java if that&rsquo;s your thing.</p>

<p>I think this algorithm is a clever little gem and I really enjoyed learning it.  Deconstructing a familiar algorithm like merge sort and utilizing its internal operations for some other purpose is a neat approach that I&rsquo;ll definitely keep in my algorithmic toolbox.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[unicode-math 0.2.0 released]]></title>
    <link href="http://adereth.github.io/blog/2013/10/13/unicode-math-0-dot-2-0-released/"/>
    <updated>2013-10-13T14:28:00-04:00</updated>
    <id>http://adereth.github.io/blog/2013/10/13/unicode-math-0-dot-2-0-released</id>
    <content type="html"><![CDATA[<p>I just deployed a new version of <a href="https://github.com/adereth/unicode-math">unicode-math</a> to Clojars.  It&rsquo;s a silly toy project that implements as many of <a href="http://symbolcodes.tlt.psu.edu/bylanguage/mathchart.html">Unicode&rsquo;s math symbols</a> as possible in Clojure.  If you <code>use</code> it, you can write things like:</p>

<p><a href="http://mathworld.wolfram.com/BinetsFibonacciNumberFormula.html">Binet&rsquo;s Fibonacci Number Formula</a>:
```clojure
(defn binet-fib [n]
  (/ (&ndash; (ⁿ φ n)</p>

<pre><code>    (ⁿ (- φ) (- n)))
 (√ 5)))
</code></pre>

<p><code>
[de Morgan's Laws](http://mathworld.wolfram.com/deMorgansLaws.html):
</code>clojure
(assert (∀ [p [true false] q [true false]]</p>

<pre><code>         (= (¬ (∧ p q))
            (∨ (¬ p) (¬ q)))))
</code></pre>

<p>```</p>

<p><a href="http://mathworld.wolfram.com/Inclusion-ExclusionPrinciple.html">Inclusion-Exclusion Principle</a>:
```clojure
(assert (= (count (∪ A B))</p>

<pre><code>       (+ (count A)
          (count B)
          (- (count (∩ A B))))))
</code></pre>

<p>```
Instructions for use are on the <a href="https://github.com/adereth/unicode-math">project&rsquo;s Github page</a>.  The full list of implemented symbols is in <a href="https://github.com/adereth/unicode-math/blob/master/src/unicode_math/core.clj">src/unicode_math/core.clj</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Add it up (properly)]]></title>
    <link href="http://adereth.github.io/blog/2013/10/10/add-it-up/"/>
    <updated>2013-10-10T22:14:00-04:00</updated>
    <id>http://adereth.github.io/blog/2013/10/10/add-it-up</id>
    <content type="html"><![CDATA[<p>Floating point arithmetic can sometimes be frustratingly <a href="https://en.wikipedia.org/wiki/Numerical_stability">unstable</a>, particularly when applied to large datasets.  Even though the classic <a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a> seems to make the front page of of Hacker News on a yearly basis (<a href="https://news.ycombinator.com/item?id=4815399">1</a>, <a href="https://news.ycombinator.com/item?id=1982332">2</a>, <a href="http://news.ycombinator.com/item?id=1937182">3</a>, <a href="http://news.ycombinator.com/item?id=1746797">4</a>, <a href="http://news.ycombinator.com/item?id=687604">5</a>,
<a href="http://news.ycombinator.com/item?id=453396">6</a>), I have never seen any big data package actually apply one of the simplest and cheapest recommendations from it.</p>

<p>I&rsquo;m talking about the <a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm">Kahan Summation algorithm</a>.  Maybe it gets ignored because it&rsquo;s covered <a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html#1076">half-way through the paper</a>.  Despite being buried, you can tell it&rsquo;s important because the author uses uncharacteristally strong language at the end of the section on the algorithm:</p>

<blockquote><p>Since these bounds hold for almost all commercial hardware, it would be foolish for numerical programmers to ignore such algorithms, and it would be irresponsible for compiler writers to destroy these algorithms by pretending that floating-point variables have real number semantics.</p></blockquote>

<p>Whoa.  Let&rsquo;s not be foolish!</p>

<h2>Example: The Harmonic Series in Clojure</h2>

<p>We&rsquo;re going to be computing a partial sum of the <a href="https://en.wikipedia.org/wiki/Harmonic_series_(mathematics)">Harmonic Series</a>:</p>

<p><img class="<a" src="href="http://upload.wikimedia.org/math/9/4/0/9402cf0c5599afa1a47d12d4a704e3de.png">http://upload.wikimedia.org/math/9/4/0/9402cf0c5599afa1a47d12d4a704e3de.png</a>" title="\sum_{n=1}^\infty\,\frac{1}{n} \;\;=\;\; 1 \,+\, \frac{1}{2} \,+\, \frac{1}{3} \,+\, \frac{1}{4} \,+\, \frac{1}{5} \,+\, \cdots.\" ></p>

<p>It&rsquo;s another nice example because it contains terms that can&rsquo;t be represented precisely in floating point and the true sum diverges.</p>

<p>Let&rsquo;s start by computing the sum with infinite precision.  Clojure&rsquo;s <a href="https://github.com/clojure/clojure/blob/229bf8fe9a751e4f48bb2b7ea57e27ebc43d26ae/src/jvm/clojure/lang/Ratio.java"><code>Ratio</code></a> class represents values internally using <a href="http://docs.oracle.com/javase/7/docs/api/java/math/BigInteger.html"><code>BigInteger</code></a> to separately store the numerator and denominator.  The summation happens using the grade-school style of making the denominators match and summing the numerators, so we have the exact running sum throughout.  At the very end, we convert the number to a floating point double:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Infinite Precision </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">harmonic-ratios</span> <span class="p">(</span><span class="nb">map / </span><span class="p">(</span><span class="nb">rest </span><span class="p">(</span><span class="nf">range</span><span class="p">))))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">take </span><span class="mi">6</span> <span class="nv">harmonic-ratios</span><span class="p">)</span>
</span><span class='line'><span class="c1">;; (1 &amp;frac12; 1/3 &amp;frac14; 1/5 1/6)&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">ndash</span><span class="c1">;&gt;&gt; harmonic-ratios (take 10000) (reduce +) double)</span>
</span><span class='line'><span class="c1">;; 9.787606036044382</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>For the first 10,000 elements, we&rsquo;ll see numerical differences starting at the 14th decimal place, so just focus on the <em>last two digits</em> in the results.</p>

<p>As expected, we see a slightly different result if we compute the sum of doubles:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Double Precision </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">harmonic-doubles</span> <span class="p">(</span><span class="nb">map double </span><span class="nv">harmonic-ratios</span><span class="p">))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">take </span><span class="mi">6</span> <span class="nv">harmonic-doubles</span><span class="p">)</span>
</span><span class='line'><span class="c1">;; (1.0 0.5 0.3333333333333333 0.25 0.2 0.1666666666666667)&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">ndash</span><span class="c1">;&gt;&gt; harmonic-doubles (take 10000) (reduce +))</span>
</span><span class='line'><span class="c1">;; 9.787606036044348 (48 vs. 82 with infinite precision)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>One approach that will get more accurate results is to use an arbitrary precision representation of the numbers, like <a href="http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html"><code>BigDecimal</code></a>.  If we naively try to convert <code>harmonic-ratios</code> to <code>BigDecimal</code>, we get an <code>ArithmeticException</code> as soon as we hit 1/3:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Converting Fractions to BigDecimals </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">bigdec</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="c1">;; 1M&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nf">bigdec</span> <span class="o">&amp;</span><span class="nv">frac12</span><span class="c1">;)</span>
</span><span class='line'><span class="c1">;; 0.5M&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nf">bigdec</span> <span class="mi">1</span><span class="nv">/3</span><span class="p">)</span>
</span><span class='line'><span class="c1">;; java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>We need to explicitly set the precision that we want using a <a href="http://docs.oracle.com/javase/7/docs/api/java/math/MathContext.html"><code>MathContext</code></a>.  Let&rsquo;s use 32 decimal places for good measure:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>32 Decimal Place Precision </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">inverse-bigdec</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">context</span> <span class="p">(</span><span class="nf">java.math.MathContext.</span> <span class="mi">32</span><span class="p">)]</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span><span class="p">(</span><span class="nf">.divide</span> <span class="p">(</span><span class="nf">bigdec</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">bigdec</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">context</span><span class="p">)))</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="k">def </span><span class="nv">harmonic-bigdecs</span> <span class="p">(</span><span class="nb">map </span><span class="nv">inverse-bigdec</span> <span class="p">(</span><span class="nb">rest </span><span class="p">(</span><span class="nf">range</span><span class="p">))))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">take </span><span class="mi">6</span> <span class="nv">harmonic-bigdecs</span><span class="p">)</span>
</span><span class='line'><span class="c1">;; (1M 0.5M 0.33333333333333333333333333333333M 0.25M 0.2M 0.16666666666666666666666666666667M)&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">ndash</span><span class="c1">;&gt;&gt; harmonic-bigdecs (take 10000) (reduce +) double)</span>
</span><span class='line'><span class="c1">;; 9.787606036044382 (perfectly matches infinite precision result)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Now, let&rsquo;s see how <a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm">Kahan Summation algorithm</a> performs on doubles:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Double Precision with Kahan Summation </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">kahan-sum</span> <span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">loop </span><span class="p">[[</span><span class="nv">x</span> <span class="o">&amp;</span><span class="nv">amp</span><span class="c1">; xs] coll sum 0.0 carry 0.0]&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span><span class="p">(</span><span class="nb">if-not </span><span class="nv">x</span> <span class="nv">sum</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">y</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x</span> <span class="nv">carry</span><span class="p">)</span> <span class="nv">t</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">y</span> <span class="nv">sum</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">recur</span> <span class="nv">xs</span> <span class="nv">t</span> <span class="p">(</span><span class="nb">- </span><span class="nv">t</span> <span class="nv">sum</span> <span class="nv">y</span><span class="p">))))))</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">ndash</span><span class="c1">;&gt;&gt; harmonic-doubles (take 10000) kahan-sum)</span>
</span><span class='line'><span class="c1">;; 9.787606036044382 (perfectly matches infinite precision result)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Everything but vanilla summation of doubles has given us the same answer!</p>

<p>To be fair to doubles, we are summing them in what intuitively is a poor order.  The smallest values are being added to the largest intermediate sums, preventing their low-order bits from accumulating.  We can try to remedy this by reversing the order:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Double Precision Reversed </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="o">&amp;</span><span class="nv">ndash</span><span class="c1">;&gt;&gt; harmonic-doubles (take 10000) reverse (reduce +))</span>
</span><span class='line'><span class="c1">;; 9.787606036044386</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Well, that&rsquo;s different.  This is the first time we&rsquo;re seeing the floating point noise lead to something larger than the infinite precision answer.</p>

<h2>Conclusion</h2>

<p>For just a couple additional floating point operations per element, we get a result that competes with the more expensive arbitrary precision solutions.  It also does better than the naive approach of pre-sorting, which is both more expensive and eliminates the ability to deal with the data in a streaming fashion.</p>

<p>In a subsequent post, I plan on covering how Kahan Summation can be used effectively in a map-reduce framework.</p>
]]></content>
  </entry>
  
</feed>
