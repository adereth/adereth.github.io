<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Add it up (properly)</title>
    <link rel="icon" type="image/png" href="/images/aleph.png">
    <link rel="stylesheet" href="/style.css">
    <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$']],
        displayMath: [['$$', '$$']]
      }
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <nav class="nav">
        <a href="/">Home</a>
        <a href="/about/">About</a>
        <a href="/feed.xml">RSS</a>
    </nav>
    <article>
        <div class="post-date">October 04, 2013</div>
        <h1>Add it up (properly)</h1>
        <p>Floating point arithmetic can sometimes be frustratingly <a href="https://en.wikipedia.org/wiki/Numerical_stability">unstable</a>, particularly when applied to large datasets.  Even though the classic <a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a> seems to make the front page of of Hacker News on a yearly basis (<a href="https://news.ycombinator.com/item?id=4815399">1</a>, <a href="https://news.ycombinator.com/item?id=1982332">2</a>, <a href="http://news.ycombinator.com/item?id=1937182">3</a>, <a href="http://news.ycombinator.com/item?id=1746797">4</a>, <a href="http://news.ycombinator.com/item?id=687604">5</a>,
<a href="http://news.ycombinator.com/item?id=453396">6</a>), I have never seen any big data package actually apply one of the simplest and cheapest recommendations from it.</p>
<p>I'm talking about the <a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm">Kahan Summation algorithm</a>.  Maybe it gets ignored because it's covered <a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html#1076">half-way through the paper</a>.  Despite being buried, you can tell it's important because the author uses uncharacteristally strong language at the end of the section on the algorithm:</p>
<blockquote>
<p>Since these bounds hold for almost all commercial hardware, it would be foolish for numerical programmers to ignore such algorithms, and it would be irresponsible for compiler writers to destroy these algorithms by pretending that floating-point variables have real number semantics.</p>
</blockquote>
<p>Whoa.  Let's not be foolish!</p>
<h2>Example: The Harmonic Series in Clojure</h2>
<p>We're going to be computing a partial sum of the <a href="https://en.wikipedia.org/wiki/Harmonic_series_(mathematics)">Harmonic Series</a>:</p>
<p><img alt="Image" src="http://upload.wikimedia.org/math/9/4/0/9402cf0c5599afa1a47d12d4a704e3de.png" /></p>
<p>It's another nice example because it contains terms that can't be represented precisely in floating point and the true sum diverges.</p>
<p>Let's start by computing the sum with infinite precision.  Clojure's <a href="https://github.com/clojure/clojure/blob/229bf8fe9a751e4f48bb2b7ea57e27ebc43d26ae/src/jvm/clojure/lang/Ratio.java"><code>Ratio</code></a> class represents values internally using <a href="http://docs.oracle.com/javase/7/docs/api/java/math/BigInteger.html"><code>BigInteger</code></a> to separately store the numerator and denominator.  The summation happens using the grade-school style of making the denominators match and summing the numerators, so we have the exact running sum throughout.  At the very end, we convert the number to a floating point double:</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">def </span><span class="nv">harmonic-ratios</span><span class="w"> </span><span class="p">(</span><span class="nb">map / </span><span class="p">(</span><span class="nb">rest </span><span class="p">(</span><span class="nf">range</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">take </span><span class="mi">6</span><span class="w"> </span><span class="nv">harmonic-ratios</span><span class="p">)</span>
<span class="c1">;; (1 1/2 1/3 1/4 1/5 1/6)</span>

<span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="nv">harmonic-ratios</span><span class="w"> </span><span class="p">(</span><span class="nb">take </span><span class="mi">10000</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">reduce </span><span class="nv">+</span><span class="p">)</span><span class="w"> </span><span class="nv">double</span><span class="p">)</span>
<span class="c1">;; 9.787606036044382</span>
</code></pre></div>

<p>For the first 10,000 elements, we'll see numerical differences starting at the 14th decimal place, so just focus on the <em>last two digits</em> in the results.</p>
<p>As expected, we see a slightly different result if we compute the sum of doubles:</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">def </span><span class="nv">harmonic-doubles</span><span class="w"> </span><span class="p">(</span><span class="nb">map double </span><span class="nv">harmonic-ratios</span><span class="p">))</span>

<span class="p">(</span><span class="nb">take </span><span class="mi">6</span><span class="w"> </span><span class="nv">harmonic-doubles</span><span class="p">)</span>
<span class="c1">;; (1.0 0.5 0.3333333333333333 0.25 0.2 0.1666666666666667)</span>

<span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="nv">harmonic-doubles</span><span class="w"> </span><span class="p">(</span><span class="nb">take </span><span class="mi">10000</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">reduce </span><span class="nv">+</span><span class="p">))</span>
<span class="c1">;; 9.787606036044348 (48 vs. 82 with infinite precision)</span>
</code></pre></div>

<p>One approach that will get more accurate results is to use an arbitrary precision representation of the numbers, like <a href="http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html"><code>BigDecimal</code></a>.  If we naively try to convert <code>harmonic-ratios</code> to <code>BigDecimal</code>, we get an <code>ArithmeticException</code> as soon as we hit 1/3:</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="nf">bigdec</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="c1">;; 1M</span>

<span class="p">(</span><span class="nf">bigdec</span><span class="w"> </span><span class="m">1/2</span><span class="p">)</span>
<span class="c1">;; 0.5M</span>

<span class="p">(</span><span class="nf">bigdec</span><span class="w"> </span><span class="m">1/3</span><span class="p">)</span>
<span class="c1">;; java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.</span>
</code></pre></div>

<p>We need to explicitly set the precision that we want using a <a href="http://docs.oracle.com/javase/7/docs/api/java/math/MathContext.html"><code>MathContext</code></a>.  Let's use 32 decimal places for good measure:</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="kd">defn </span><span class="nv">inverse-bigdec</span><span class="w"> </span><span class="p">[</span><span class="nv">n</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">context</span><span class="w"> </span><span class="p">(</span><span class="nf">java.math.MathContext.</span><span class="w"> </span><span class="mi">32</span><span class="p">)]</span>
<span class="w">    </span><span class="p">(</span><span class="nf">.divide</span><span class="w"> </span><span class="p">(</span><span class="nf">bigdec</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">bigdec</span><span class="w"> </span><span class="nv">n</span><span class="p">)</span><span class="w"> </span><span class="nv">context</span><span class="p">)))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">harmonic-bigdecs</span><span class="w"> </span><span class="p">(</span><span class="nb">map </span><span class="nv">inverse-bigdec</span><span class="w"> </span><span class="p">(</span><span class="nb">rest </span><span class="p">(</span><span class="nf">range</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">take </span><span class="mi">6</span><span class="w"> </span><span class="nv">harmonic-bigdecs</span><span class="p">)</span>
<span class="c1">;; (1M 0.5M 0.33333333333333333333333333333333M 0.25M 0.2M 0.16666666666666666666666666666667M)</span>

<span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="nv">harmonic-bigdecs</span><span class="w"> </span><span class="p">(</span><span class="nb">take </span><span class="mi">10000</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">reduce </span><span class="nv">+</span><span class="p">)</span><span class="w"> </span><span class="nv">double</span><span class="p">)</span>
<span class="c1">;; 9.787606036044382 (perfectly matches infinite precision result)</span>
</code></pre></div>

<p>Now, let's see how <a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm">Kahan Summation algorithm</a> performs on doubles:</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="kd">defn </span><span class="nv">kahan-sum</span><span class="w"> </span><span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">loop </span><span class="p">[[</span><span class="nv">x</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nv">xs</span><span class="p">]</span><span class="w"> </span><span class="nv">coll</span><span class="w"> </span><span class="nv">sum</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="nv">carry</span><span class="w"> </span><span class="mf">0.0</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">if-not </span><span class="nv">x</span><span class="w"> </span><span class="nv">sum</span>
<span class="w">      </span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">y</span><span class="w"> </span><span class="p">(</span><span class="nb">- </span><span class="nv">x</span><span class="w"> </span><span class="nv">carry</span><span class="p">)</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="nv">y</span><span class="w"> </span><span class="nv">sum</span><span class="p">)]</span>
<span class="w">        </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="nv">xs</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="p">(</span><span class="nb">- </span><span class="nv">t</span><span class="w"> </span><span class="nv">sum</span><span class="w"> </span><span class="nv">y</span><span class="p">))))))</span>

<span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="nv">harmonic-doubles</span><span class="w"> </span><span class="p">(</span><span class="nb">take </span><span class="mi">10000</span><span class="p">)</span><span class="w"> </span><span class="nv">kahan-sum</span><span class="p">)</span>
<span class="c1">;; 9.787606036044382 (perfectly matches infinite precision result)</span>
</code></pre></div>

<p>Everything but vanilla summation of doubles has given us the same answer!</p>
<p>To be fair to doubles, we are summing them in what intuitively is a poor order.  The smallest values are being added to the largest intermediate sums, preventing their low-order bits from accumulating.  We can try to remedy this by reversing the order:</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="nv">harmonic-doubles</span><span class="w"> </span><span class="p">(</span><span class="nb">take </span><span class="mi">10000</span><span class="p">)</span><span class="w"> </span><span class="nb">reverse </span><span class="p">(</span><span class="nb">reduce </span><span class="nv">+</span><span class="p">))</span>
<span class="c1">;; 9.787606036044386</span>
</code></pre></div>

<p>Well, that's different.  This is the first time we're seeing the floating point noise lead to something larger than the infinite precision answer.</p>
<h2>Conclusion</h2>
<p>For just a couple additional floating point operations per element, we get a result that competes with the more expensive arbitrary precision solutions.  It also does better than the naive approach of pre-sorting, which is both more expensive and eliminates the ability to deal with the data in a streaming fashion.</p>
<p>In a subsequent post, I plan on covering how Kahan Summation can be used effectively in a map-reduce framework.</p>
    </article>
    <footer class="post-footer">
        <a href="/" class="home-link">‚Üê Back to Home</a>
    </footer>
</body>
</html>